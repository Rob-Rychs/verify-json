"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.verify=void 0;var _slicedToArray=function(){function a(a,b){var c=[],d=!0,e=!1,f=void 0;try{for(var g,h=a[Symbol.iterator]();!(d=(g=h.next()).done)&&(c.push(g.value),!(b&&c.length===b));d=!0);}catch(a){e=!0,f=a}finally{try{!d&&h["return"]&&h["return"]()}finally{if(e)throw f}}return c}return function(b,c){if(Array.isArray(b))return b;if(Symbol.iterator in Object(b))return a(b,c);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),_lodash=require("lodash"),_lodash2=_interopRequireDefault(_lodash);function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}var verify=function(a,b){function c(a){for(var b=void 0,d=!1;(b=a.match(/(\[[^\[\]\{\}]*\])/))||(b=a.match(/(\{[^\{\}\[\]]*\})/));)a=a.substr(0,b.index)+f.length+a.substr(b.index+b[0].length),b[0].match(/^\[/)&&(b[0]=b[0].replace(/\:/g,"")),f.push(b[0]),d=!0;if(d&&c(a),!d&&(a.match(/[\[\]]/)||a.match(/[\{\}]/)))throw"Malformed schema";return a}//console.log("lookups", lookups);
// flat validator
function d(a,b,c){//console.log("validate", obj, sch);
var h=void 0,j=null,l=!1;if(c.match(/^\!/)&&(c=c.substr(1),l=!0),l&&(void 0===b||null===b))return!0;// if lookup, validate further
if(h=c.match(/^[0-9]+$/))return d(""+a,b,f[1*c]);// if validator verify it now
if(c.match(/^[a-zA-Z0-9]*$/)){if(void 0===b||null===b)return g.push(a+": is required"),!1;if(""===c)return!0;// no validation needed
// given a validator. we verify above so should never throw this
if(!e[c])throw c+" : Validator specified in JSON schema not found";else return!!e[c](b)||(g.push(a+": validation failed"),!1)}if(h=c.match(/^\[(.*)\]$/)){if(!_lodash2.default.isArray(b))return g.push(a+": should be array"),!1;j="array",c=h[1]}else if(h=c.match(/^\{(.*)\}$/)){if(!_lodash2.default.isPlainObject(b))return g.push(a+": should be object"),!1;j="object",c=h[1]}// This should never happen as well
if(!j)throw a+": Invalid type in Lookup";// if array, validate for all
if("array"===j){var n=c.split(",");for(var o in b)d(a+"."+o,b[o],n[o%n.length])}if("object"===j&&""!==c){var i=c.split(",").reduce(function(a,b){var c=b.split(":"),d=_slicedToArray(c,2),e=d[0],f=d[1];return f||(f=""),a[e]=f,a},{});// if object, validate for all k-v
for(var p in i)d(a+"."+p,b[p],i[p])}}var e=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};// verify the format of validators
if(!_lodash2.default.isEmpty(e))try{verify(e,"{"+Object.keys(e).map(function(a){return a+":f"}).join(",")+"}")}catch(a){throw a.replace("json.","validators.")}// extend validators with inbuilts
e=Object.assign({string:_lodash2.default.isString,s:_lodash2.default.isString,number:_lodash2.default.isNumber,n:_lodash2.default.isNumber,boolean:_lodash2.default.isBoolean,b:_lodash2.default.isBoolean,integer:_lodash2.default.isInteger,i:_lodash2.default.isInteger,func:_lodash2.default.isFunction,f:_lodash2.default.isFunction,an:function b(a){return a.match(/^[a-zA-Z0-9]+$/)}// alpha numeric, mainly internal use
},e),b=b.replace(/\s/g,"");var f=[],g=[];if(b=c(b),function(){function a(a,b){if(a&&""!==a)if(a.match(/^[0-9]+$/)){if(1*a>=b)throw"Invalid validator: "+a;}else if(!e[a])throw"Invalid validator: "+a}// validate validators. lookups provide the validator tokens.
f.forEach(function(b,c){var d;(d=b.match(/^\[(.+)\]$/))?d[1].split(",").forEach(function(b){return a(b,c)}):(d=b.match(/^\{(.+)\}$/))&&d[1].replace(/\!/g,"").split(",").forEach(function(b){var d=b.split(":"),e=_slicedToArray(d,2),f=e[0],g=e[1];a(g,c)})})}(),d("json",a,b),0<g.length)throw g.join(", ");return!0};_lodash2.default.mixin({verify:verify},{chain:!1}),exports.default=verify,exports.verify=verify;